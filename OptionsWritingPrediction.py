# -*- coding: utf-8 -*-
"""StockMarketPredictionV6

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1MNsqVxQNzeUDcdvI3e3aYbhtCbmlFTFb
"""

from google.colab import drive
drive.mount('/content/grdive')

cd grdive/My\ Drive

cd StockMarketAnalysisV2/

!pip install yahoo_fin

import pandas as pd
import pandas_datareader.data as web
import datetime as dt
import csv
from sklearn import preprocessing
from sklearn.preprocessing import StandardScaler
import numpy as np
from collections import deque
import tensorflow as tf
from tensorflow.keras.models import Sequential 
from tensorflow.keras.layers import Dense,Dropout,LSTM,CuDNNLSTM,BatchNormalization
import math
from datetime import datetime
from dateutil.relativedelta import relativedelta
from datetime import date
from yahoo_fin import stock_info as si

difference = datetime.now() - relativedelta(years=4)
startday = dt.datetime(difference.year, difference.month, difference.day)
endday = dt.datetime(datetime.now().year,datetime.now().month, datetime.now().day)

result = web.DataReader('BAC', 'yahoo', startday, endday)
result.to_csv('BAC.csv') #store in csv file

result = web.DataReader('DLTR', 'yahoo', startday, endday)
result.to_csv('DLTR.csv') #store in csv file

result = web.DataReader('F', 'yahoo', startday, endday)
result.to_csv('F.csv') #store in csv file

result = web.DataReader('GE', 'yahoo', startday, endday)
result.to_csv('GE.csv') #store in csv file

result = web.DataReader('MSFT', 'yahoo', startday, endday)
result.to_csv('MSFT.csv') #store in csv file

main_df=pd.DataFrame() #initialize empty dataframe

ratios=["BAC","F","GE","MSFT","DLTR"]
for ratio in ratios:
  dataset=f"{ratio}.csv"
  df=pd.read_csv(dataset)
  df.rename(columns={"High":f"{ratio}_High","Low":f"{ratio}_Low","Open":f"{ratio}_Open",
                    "Close":f"{ratio}_Close","Volume":f"{ratio}_Volume","Adj Close":f"{ratio}_Adj Close"},
           inplace=True)
  df.set_index("Date",inplace=True)
  
  if len(main_df) ==0:  
    main_df=df          #store df in main_df if main_df is empty   
  else:
    main_df=main_df.join(df) #concate all df dataframes to main_df

len(main_df)

#ALL CONSTANTS TO BE USED IN PROGRAM
SEQ_LEN=300
FUTURE_PERIOD_PREDICT=30
FUTURE_DAYS=30 
HISTORICAL_DATA=len(main_df)
TRAIN_DATA=HISTORICAL_DATA-300-29
TEST_DATA=TRAIN_DATA+FUTURE_DAYS-1
print(HISTORICAL_DATA)
print(TRAIN_DATA)
print(TEST_DATA)
#RATIO_TO_PREDICT="DLTR"

for c in main_df.columns:
  print(c)

#create a future coloumn with value same as specific high coloumn & specific low coloumn
#which is shifted up by specific value

main_df['future_High_BAC']=main_df["BAC_High"].shift(-FUTURE_PERIOD_PREDICT)
main_df['future_Low_BAC']=main_df["BAC_Low"].shift(-FUTURE_PERIOD_PREDICT)


main_df['future_High_DLTR']=main_df["DLTR_High"].shift(-FUTURE_PERIOD_PREDICT)
main_df['future_Low_DLTR']=main_df["DLTR_Low"].shift(-FUTURE_PERIOD_PREDICT)


main_df['future_High_F']=main_df["F_High"].shift(-FUTURE_PERIOD_PREDICT)
main_df['future_Low_F']=main_df["F_Low"].shift(-FUTURE_PERIOD_PREDICT)


main_df['future_High_GE']=main_df["GE_High"].shift(-FUTURE_PERIOD_PREDICT)
main_df['future_Low_GE']=main_df["GE_Low"].shift(-FUTURE_PERIOD_PREDICT)


main_df['future_High_MSFT']=main_df["MSFT_High"].shift(-FUTURE_PERIOD_PREDICT)
main_df['future_Low_MSFT']=main_df["MSFT_Low"].shift(-FUTURE_PERIOD_PREDICT)

print(main_df[["BAC_High","future_High_BAC","BAC_Low","future_Low_BAC",
               "DLTR_High","future_High_DLTR","DLTR_Low","future_Low_DLTR",
               "F_High","future_High_F","F_Low","future_Low_F",
               "GE_High","future_High_GE","GE_Low","future_Low_GE",
              "MSFT_High","future_High_MSFT","MSFT_Low","future_Low_MSFT"]])

for c in main_df.columns:
  print(c)

X=main_df.iloc[:,:-10] #Independent variable

for c in X.columns:
  print(c)

Y=main_df.iloc[:,30:40]  # Dependent coloum in Y

for c in Y.columns:
  print(c)

sc_X=StandardScaler()
sc_Y=StandardScaler()

X=sc_X.fit_transform(X)
Y=sc_Y.fit_transform(Y)

Z=np.concatenate((X,Y),axis=1)

sequential_data=[]
prev_days=deque(maxlen=SEQ_LEN)

print((Z.shape))

#Creates the complete sequential data to be split into train and test sequences
for i in range(0,len(Z)-1):
  prev_days.append([n for n in Z[i][:-10]])
  if len(prev_days) ==SEQ_LEN:
    sequential_data.append([np.array(prev_days),str(Z[i][-10])+" "+str(Z[i][-9])+" "+str(Z[i][-8])
                           +" "+str(Z[i][-7])+" "+str(Z[i][-6])+" "+str(Z[i][-5])+" "+str(Z[i][-4])
                           +" "+str(Z[i][-3])+" "+str(Z[i][-2])+" "+str(Z[i][-1])])

sequential_data_train=[]
sequential_data_test=[]
sequential_data_train=sequential_data[0:TRAIN_DATA]  #0:908  #679
sequential_data_test=sequential_data[TRAIN_DATA:TEST_DATA]  #908:

x_train=np.empty((TRAIN_DATA,SEQ_LEN,30)) #908 rows, 90 coloums, 30 values in a cell
y_train=np.empty((TRAIN_DATA,10)) #908 rows, 2 coloums

for i in range(len(sequential_data_train)):
  x_train[i]=sequential_data_train[i][0].tolist()

x_train.shape

for i in range(len(sequential_data_train)):
  y_train[i][0]=float(sequential_data_train[i][1].split()[0])
  y_train[i][1]=float(sequential_data_train[i][1].split()[1])
  y_train[i][2]=float(sequential_data_train[i][1].split()[2])
  y_train[i][3]=float(sequential_data_train[i][1].split()[3])
  y_train[i][4]=float(sequential_data_train[i][1].split()[4])
  y_train[i][5]=float(sequential_data_train[i][1].split()[5])
  y_train[i][6]=float(sequential_data_train[i][1].split()[6])
  y_train[i][7]=float(sequential_data_train[i][1].split()[7])
  y_train[i][8]=float(sequential_data_train[i][1].split()[8])
  y_train[i][9]=float(sequential_data_train[i][1].split()[9])

model=Sequential()

model.add(CuDNNLSTM(128,input_shape=(SEQ_LEN,30),return_sequences=True))  #value should be(90,30)
model.add(Dropout(0.2))
model.add(BatchNormalization())

model.add(CuDNNLSTM(128,input_shape=(SEQ_LEN,30),return_sequences=True))  #value should be(90,30)
model.add(Dropout(0.1))
model.add(BatchNormalization())

model.add(CuDNNLSTM(128,input_shape=(SEQ_LEN,30)))  #value should be(90,30)
model.add(Dropout(0.2))
model.add(BatchNormalization())

#Output Layer 
#model.add(Dense(1,activation="softmax")) #it was linear
model.add(Dense(10))

model.compile(optimizer='rmsprop',
              loss='mse',
             metrics=['mae'])

model.fit(x_train,y_train,batch_size=10,epochs=30)

y_pred_train=sc_Y.inverse_transform(model.predict(x_train))

for i in range(len(y_pred_train)):
  print(str(y_pred_train[i][0]) +" "+str(y_pred_train[i][1])
        +" "+str(y_pred_train[i][2]) +" "+str(y_pred_train[i][3])
        +" "+str(y_pred_train[i][4]) +" "+str(y_pred_train[i][5])
        +" "+str(y_pred_train[i][6]) +" "+str(y_pred_train[i][7])
        +" "+str(y_pred_train[i][8]) +" "+str(y_pred_train[i][9]))

#create x_test data
x_test=np.empty((FUTURE_PERIOD_PREDICT,SEQ_LEN,30))

for i in range(len(sequential_data_test)):
  x_test[i]=sequential_data_test[i][0].tolist()

print(x_test)

y_pred_test=sc_Y.inverse_transform(model.predict(x_test))

print(y_pred_test)

#IN THE MONEY CALL OPTION

optionRiskFactor={}
companies=["BAC ","DLTR ","F ","GE ","MSFT "]
expirationDates=["2019-5-3","2019-5-10","2019-5-17"]
count=0
for company in companies:
  for expirationDate in expirationDates:
    expYear=int(expirationDate.split('-')[0])
    expMonth=int(expirationDate.split('-')[1])
    expDay=int(expirationDate.split('-')[2])

    
    daysToExpiry=abs(date(expYear,expMonth,expDay)
                 -date(datetime.now().year,datetime.now().month,datetime.now().day)).days+1 
    
    
    completeStockPrediction=[]
    
    for i in range(daysToExpiry):
      completeStockPrediction.append(y_pred_test[i][count])
      completeStockPrediction.append(y_pred_test[i][count+1])
      
      #IN THE MONEY CALL OPTION STRIKE PRICE < STOCK PRICE
      minPrice= min(completeStockPrediction)  #minimum predicted price
      maxPrice=  max(completeStockPrediction) #maximum predicted price
      avgPrice=  sum(completeStockPrediction)/len(completeStockPrediction) #average predicted price
      print("Company Name "+company+" Days to expire "+str(i)
                   +" Min Price "+str(minPrice)+" Max Price "+str(maxPrice)+" Avg Price "+str(avgPrice))
     # priceFluctuation=  avgPrice-minPrice#avgPrice-minPrice
      riskPriceFactor=((maxPrice-avgPrice)/float(avgPrice))*100#maxPrice-priceRange
      
      optionRiskFactor[f"{company+expirationDate}"]=riskPriceFactor
  
  count=count+2

print("LIST OF OPTIONS IN MONEY MOST RISKY TO LEAST")
temp=len(sorted((value,key) for (key,value) in optionRiskFactor.items()))
for i in range(temp):
  print(sorted((value,key) for (key,value) in optionRiskFactor.items())[i][1])

max_key = max(optionRiskFactor, key=lambda k: optionRiskFactor[k]) # get the key with with minimum value
print(max_key)
selectedCompany=max_key.split()[0]

#Find the expiration date for the selected company
highColoumIndex=(main_df.columns =="future_High_"+max_key.split()[0]).nonzero()[0][0]-30
expYear=int((max_key.split()[1]).split('-')[0])
expMonth=int((max_key.split()[1]).split('-')[1])
expDay=int((max_key.split()[1]).split('-')[2])
T=abs(date(expYear,expMonth,expDay)
                 -date(datetime.now().year,datetime.now().month,datetime.now().day)).days
print("Days to expiry "+str(T))

print(si.get_live_price(selectedCompany))

specificStockPrediction=[]
belowStockPrice=[]
aboveStockPrice=[]
stockPrice=si.get_live_price(selectedCompany)
print("Current stock price "+str(stockPrice))
for i in range(T+1):
      specificStockPrediction.append(y_pred_test[i][highColoumIndex])    #high valued coloums
      specificStockPrediction.append(y_pred_test[i][highColoumIndex+1])  #low valued coloums
print((specificStockPrediction))

for i in range(len(specificStockPrediction)):   #it was completeStockPrediction
  if(specificStockPrediction[i]<=stockPrice):
    belowStockPrice.append(specificStockPrediction[i])
  if(specificStockPrediction[i]>stockPrice):
    aboveStockPrice.append(specificStockPrediction[i])
print(belowStockPrice)
print((aboveStockPrice))

if len(belowStockPrice) == 0:
  belowStockPrice =[]
  belowStockPrice.append(stockPrice)
if len(aboveStockPrice) == 0:
  aboveStockPrice=[]
  aboveStockPrice.append(stockPrice)
for t in range(T+1):
  #Maximum Risk
  InMoneyOptionPriceHighRisk=(max(aboveStockPrice)-max(belowStockPrice))+math.pow(math.e,-t/T)
  print("In Money Call Option Price on Day: "+str(t+1)+" is "+str(InMoneyOptionPriceHighRisk))

#OUT OF Money CALL OPTION

#Take the minimum of Max -average
optionRiskFactor={}
companies=["BAC ","DLTR ","F ","GE ","MSFT "]
expirationDates=["2019-5-3","2019-5-10","2019-5-17"]
count=0
for company in companies:
  for expirationDate in expirationDates:
    expYear=int(expirationDate.split('-')[0])
    expMonth=int(expirationDate.split('-')[1])
    expDay=int(expirationDate.split('-')[2])

    
    daysToExpiry=abs(date(expYear,expMonth,expDay)
                 -date(datetime.now().year,datetime.now().month,datetime.now().day)).days+1 
    
    completeStockPrediction=[]
    
    for i in range(daysToExpiry):
      completeStockPrediction.append(y_pred_test[i][count])
      completeStockPrediction.append(y_pred_test[i][count+1])
      
      #OUT OF MONEY CALL OPTION STRIKE PRICE > STOCK PRICE
      #minPrice= min(completeStockPrediction)  #minimum predicted price
      maxPrice=  max(completeStockPrediction) #maximum predicted price
      avgPrice=  sum(completeStockPrediction)/len(completeStockPrediction) #average predicted price
     # priceFluctuation=  maxPrice-avgPrice#avgPrice-minPrice
    
      print("Company Name "+company+" Days to expire "+str(i)
                   +" Min Price "+str(minPrice)+" Max Price "+str(maxPrice)+" Avg Price "+str(avgPrice))
      
      riskPriceFactor=((maxPrice-avgPrice)/float(avgPrice))*100
      
      optionRiskFactor[f"{company+expirationDate}"]=riskPriceFactor
  
  count=count+2

print("LIST OF OPTIONS FOR OUT OF MONEY MOST RISKY TO LEAST")
temp=len(sorted((value,key) for (key,value) in optionRiskFactor.items()))
for i in range(temp):
  print(sorted((value,key) for (key,value) in optionRiskFactor.items())[i][1])

max_key = max(optionRiskFactor, key=lambda k: optionRiskFactor[k]) # get the key with with minimum value
selectedCompany=max_key.split()[0]
print(max_key)

#Find the expiration date for the selected company
highColoumIndex=(main_df.columns =="future_High_"+max_key.split()[0]).nonzero()[0][0]-30
expYear=int((max_key.split()[1]).split('-')[0])
expMonth=int((max_key.split()[1]).split('-')[1])
expDay=int((max_key.split()[1]).split('-')[2])
T=abs(date(expYear,expMonth,expDay)
                 -date(datetime.now().year,datetime.now().month,datetime.now().day)).days
print("Days to expiry "+str(T))

specificStockPrediction=[]
aboveStockPrice=[]
stockPrice=si.get_live_price(selectedCompany)                            #GET LIVE PRICE OF STOCK
print("Current stock price "+str(stockPrice))
for i in range(T+1):
      specificStockPrediction.append(y_pred_test[i][highColoumIndex])    #high valued coloums
      specificStockPrediction.append(y_pred_test[i][highColoumIndex+1])  #low valued coloums
print((specificStockPrediction))

for i in range(len(specificStockPrediction)):
  if(specificStockPrediction[i]>stockPrice):
    aboveStockPrice.append(specificStockPrediction[i])
print((aboveStockPrice))

if type(belowStockPrice) == int:
  belowStockPrice =[]
  belowStockPrice.append(stockPrice)
if len(aboveStockPrice) == 0:
  aboveStockPrice=[]
  aboveStockPrice.append(stockPrice)
for t in range(T+1):
  #Maximum Risk
  InMoneyOptionPriceHighRisk=(max(aboveStockPrice)-min(aboveStockPrice))+math.pow(math.e,-t/T)
  print("Out of Money Call Option Price on Day: "+str(t+1)+" is "+str(InMoneyOptionPriceHighRisk))

si.get_live_price("BAC")